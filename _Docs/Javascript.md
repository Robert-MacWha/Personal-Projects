# Javascript Projects
All Javascript projects are hosted on p5.js and are therefor usable in the browser.  If you want to run any of the projects on your local machine I recommend using visual studio code and its 'Live Server' extension.

## AI
<img align="right" width="20%" src="../_Docs\Images\Polynomial-Regression.gif"></img>
- Manual Neural Network
- XOR Visualization
- :star: Polynomial Regression

## Artificial Life
- Population Growth Model
- Langdon's Ant
- Boids
- Steering Agents
- :star: Smart Rockets

## Miscellaneous
- Path Difference Calculator
- Directional Path Difference Calculator
- Calculating PI With Blocks
- Calculating PI With Fractions

## Perlin Noise
<img align="right" width="20%" src="../_Docs\Images\Coloured-2D-Islands.PNG"></img>
- Perlin Noise VS Random Noise
- Coloured 2D Islands
- Warped 2D Islands
- Ridged Noise Heightmap
- Worley Noise
- Noisy Flow Chart

## Physics Simulations
- Lorenz Attractor
- Low-Poly Ocean
- Raycasting
- Spring Simulation
- Water Particle Simulation
- :star: Wireworld

## Visualizations
<img align="right" width="30%" src="../_Docs\Images\Marching-Squares.gif"></img>
- Arbitrary Function Mapper
- Complex Equation Grapher
- Quadtree Implementation
- Fourier Series
- Fourier Transform
- Fractal Generator
- Fractal Fern Generator
- Vertex Shader Test
- :star: Marching Squares

### Manuel Neural Network - Article Aid
A simple manuel neural network I created as an aid for a article I wrote on machine learning.  This neural network (or more accurately, linear equation) is made up of two variables, <b>m</b> and <b>b</b>, which are controlled by the user using sliders.

This project is also one of the more presentable projects I have created.  It has been a goal of mine to make all of the other projects as user-friendly as this one but seeing as there are (as of today) over 30 unformatted projects, I think it's best to just commit to making new projects in this style.

A live version of this project can be found [here]()

### XOR Visualization
A basic tensorflow model that solves the XOR logic gate:

| Input [A] | Input [B] | Output [A XOR B] |
| --- | --- | --- |
| 0 | 0 | 0 |
| 1 | 0 | 1 |
| 0 | 1 | 1 |
| 1 | 1 | 0 |

<img align="left" width="20%" src="../_Docs\Images\XOR-Visualization.PNG"></img>

The unique portion of this project is that it also shows you the solutions to non-binary inputs.  As an example, you might pass in 0.5 for A and 0.7 for B.  The model will tell you what 0.7 XOR 0.5 is.

This machine learning project was the first time I created something using a proper ML library.  While projects such as my NEAT implementation and NEAT racecars were created before this, those projects had serious limitations (namely being made using a very ineffective implementation of NEAT).

A precursor to my [Polynomial Regression project](#polynomial-regression).

A live version of this project can be found [here]()

### Polynomial Regression
<img align="right" width="25%" src="../_Docs\Images\Polynomial-Regression.gif"></img>
A basic polynomial regression model written in tensorflow JS.  The user places points on the canvas and defines the degree of the polynomial, after which tensorflow optimizes the values of the polynomial's coefficients to meet all the points.

Limitations of this implementation are that it cannot loop back over itself (due to it being a function) and therefor can't always link up every point.  I plan to make a similar project which uses complex numbers that would be able form any shape.

A live version of this project can be found [here]()

### Population Growth Model
A simple JS script that shows the population growth as growth rate increases.  This project was created after I watched [this video](https://www.youtube.com/watch?v=ovJcsL7vyrk) by Veritasium.  I want to at some point expand this project so I can show the entire fractal generated by higher growths in a single image.

A live version of this project can be found [here]()

### Langdon's Ant Cellular Automata
An implementation of the cellular automata 'Langdon's Ant.'  This cellular automata works by creating an 'ant' which acts based on the following rules:

1. Move forwards
1. If the current cell is black turn to the left
1. If the current cell is white turn to the right
1. Repeat

This ruleset inevitable returns to a stable pattern that can be observed if you let the simulation run on for long enough.

This project also has the capacity to create a world with multiple ants.  However, there is no UI for this process so be prepared to venture into the code.

A live version of this project can be found [here]()

### Steering Agents
A project I created white attempting to make an artificial life system.  Each agent contains four genes controlling their perception radius and desires.

This project is fully automatic and should run indefinitely.  While it does technically work as designed the agents don't generally evolve at all since they die to often.

A live version of this project can be found [here]()

### Smart Rockets
<img align="right" width="35%" src="../_Docs\Images\Smart-Rockets.PNG"></img>
A mid-scale project I created while learning about different ML techniques.  This project involved creating a species of smart rockets which follow a evolved set of instructions to try and reach a goal.  Since this is a relatively primitive ML approach the instructions are simply a set of acceleration vectors.  The best-preforming rockets will have a higher chance to pass down their genes, which will be randomly mutated between generations.

This project also includes a live graph which shows information relating to the overall performance of the rockets.

A live version of this project can be found [here]()

### Path Difference Calculator
A program I created while trying to create a simple OCR system for a VR game I was creating. This system was inspired in part by the summoning system in Pokemon Rangers - guardian signs, and attempts to categories paths drawn on a 2d plane based on how closely they match a set of pre-generated paths. 

This implementation works by splitting a path up into a set of points.  It then tracks where the user is drawing along said path and detects when the user moves too far from the line.

A live version of this project can be found [here]()

### Directional Path Difference Calculator
A second program I created for the VR game, this one focusing on categorising paths based on their directionality.  This was created to solve a few limitations in the above project, namely that if a path was stretched or squashed it would not be detected.

This implementation works by taking the path drawn by the user and splitting it up into a simplified vector representation.  This vector representation can then be compared with other paths in a pre-generated dataset and matches can be found.

The new limitations introduced by this implementations are that paths cannot be too complex or have too many different directions.  Since the classification works by splitting up the path into a set of vectors there needs to be a limited number of vectors.  In this project I chose to normalize everything to just 8 directional vectors, the 4 cardinal directions and the in-between directions.

A live version of this project can be found [here]()

### Calculating PI With Blocks
This is a simple project created for PI-day that calculates PI to n (where n < 10) digits using collisions between moving blocks.

A live version of this project can be found [here]()

### Calculating PI With Fractions
This is a simple project created for PI-day that calculates PI using an infinite series.

A live version of this project can be found [here]()

### Perlin Noise VS Random Noise - Article Aid
A simple project created as an aid for an article on the differences between perlin and random noise.

A live version of this project can be found [here]()

### Coloured 2D Islands - Article Aid
<img align="right" width="35%" src="../_Docs\Images\Coloured-2D-Islands.PNG"></img>
A small-scale project I created that demonstrates an interactive island generator which uses layered perlin noise.

A live version of this project can be found [here]()

### Warped 2D Islands - Article Aid
A small-scale project I created that demonstrates an interactive island generator which uses layered warped perlin noise.

A live version of this project can be found [here]()

### Ridged Noise Heightmap - Article Aid
A small-scale project I created that demonstrates how to generate ridged noise from perlin noise.

A live version of this project can be found [here]()

### Worley Noise
A program I created that attempted to generate worley noise.  Originally this was meant to go inside of my perlin noise article but I decided to cut it since I couldn't make it run fast enough in the browser (without using vertex shaders).

A precursor to my [Vertex Shader Test project](#vertex-shader-test) which attempted to make this sketch run faster.

A live version of this project can be found [here]()

### Noise Flow Chart
A small visualization I created that attempts to create shapes similar to that of a river.  This project uses particles who's acceleration vector is defined by the perlin noise at their position to trace out paths.

A live version of this project can be found [here]()

### Lorenz Attractor
An implementation of a lorenz system - a system of differential equations which have chaotic solutions.  This particular implementation also has built-in functionality to preform transformations and rotations to the entire 3d space (which creates really cool flowery visuals).  This functionality is however only accessible via code.

A live version of this project can be found [here]()

### Low-Poly Ocean
A basic project I created which generates a 3D low-poly ocean.  Despite being 3D, all of the rendering for this project was done using p5.js' basic 2d systems.  Lighting was also calculated manually using the relative positions of the vertices on each tri.

A live version of this project can be found [here]()

### Raycasting
A basic raycasting program I created while I was still interested in created games in Scratch.  At that time I found it easier to work through problems in javascript and then port them over to Scratch.  The final project would have generated 3d perspective through a system similar to that within games like Wolfenstein or Doom. 

A live version of this project can be found [here]()

### Spring Simulation
A basic physics simulation I created that models spring equations created while I was learning about springs in physics class.

A live version of this project can be found [here]()

### Water Particle Simulation
<img align="left" width="20%" src="../_Docs\Images\Water-Simulation.gif"></img>
A particle simulation that I created in an attempt to replicate the motions of water.  This project was originally meant to be a full 3d liquid simulator but I have since abandoned that functionality after realizing how complex it is to make liquid simulators.

A precursor to my [Water Particle Simulation project](./Java.md) written in Processing (Java).

A live version of this project can be found [here]()

### Wireworld
<img align="right" width="20%" src="../_Docs\Images\Wireworld.PNG"></img>
A simple implementation of the wireworld cellular automata.  I originally planned to implement more complex logic gates (currently only the and gate exists) but decided against it once I bought an arduino.

A live version of this project can be found [here]()

### Arbitrary Function Mapper
A simple program that I use to generate graphs of arbitrary functions.  I find this endlessly entertaining.

A live version of this project can be found [here]()

### Complex Equation Grapher
<img align="left" width="20%" src="../_Docs\Images\Complex-Equation.PNG"></img>
A simple program that I created while learning about complex numbers and also because I found the limitations of my [Arbitrary Function Mapper](#arbitrary-function-mapper) annoying.  This program should in theory be able to graph any complex function (at least, that I know of).

A live version of this project can be found [here]()

### Quadtree Implementation
An implementation of the quadtree algorithm, a system used to subdivide space based on the number of points within said space.  This was originally designed to be used in my water particle simulation project but before being implemented I realized that it would be faster to just write a compute shader in unity.

A live version of this project can be found [here]()

### Fourier Series
A basic fourier series which models a square wave using <b>n</b> sin waves.

A precursor to my [Fourier Transform Project](#fourier-transform)

A live version of this project can be found [here]()

### Fourier Transform
An implementation of the fourier transform algorithm which is able to trace out any continuous path using a pair of two sinusoidal tracers.

A live version of this project can be found [here]()

### Fractal Generator
A simple pure JS project which generates a fractal from the Julia Set.

A live version of this project can be found [here]()

### Fractal Fern Generator
<img align="right" width="15%" src="../_Docs\Images\Fern.PNG"></img>
A simple JS project that somehow generates a fractal fern by repeatedly moving a point around.  I still have no idea how it works but it's really cool.

A live version of this project can be found [here]()

### Vertex Shader Test
A project I created while trying to learn about vertex shaders.  Originally made to try and speed up my water particle simulation I abandoned that goal because

1. I wasn't able to figure out how to pass multiple variables into the shaders
2. I found out that unity supported compute shaders and ran them much faster.

A live version of this project can be found [here]()

### Marching Squares
<img align="left" width="20%" src="../_Docs\Images\Marching-Squares.gif"></img>
An implementation of the marching squares algorithm which I created while learning about different 2d rendering techniques.  I originally planned to turn this into a map editor but found it more fun to just let the shapes change using perlin noise.

A precursor to my [Marching Cubes Project](https://github.com/Robert-MacWha/Marching-Cubes-in-Unity) written in the Unity Game Engine.

A live version of this project can be found [here]()